# Stage 6: Integration & Polish Implementation

**Goal**: End-to-end integration, testing, and documentation. Prove that Pristine can generate a complete Tinkex client from a manifest.

**Dependencies**: All previous stages (0-5) must be completed first.

---

## Required Reading

### Architecture Audit Documents (Read First)

```
/home/home/p/g/n/pristine/docs/20251228/pristine-arch-audit/overview.md
/home/home/p/g/n/pristine/docs/20251228/pristine-arch-audit/gap-analysis.md
/home/home/p/g/n/pristine/docs/20251228/pristine-arch-audit/roadmap.md
/home/home/p/g/n/pristine/docs/20251228/pristine-arch-audit/01-types-schema-mapping.md
/home/home/p/g/n/pristine/docs/20251228/pristine-arch-audit/02-client-resource-mapping.md
```

### Pristine Source Files

```
/home/home/p/g/n/pristine/lib/pristine.ex
/home/home/p/g/n/pristine/lib/pristine/manifest.ex
/home/home/p/g/n/pristine/lib/pristine/manifest/endpoint.ex
/home/home/p/g/n/pristine/lib/pristine/manifest/type_def.ex
/home/home/p/g/n/pristine/lib/pristine/codegen.ex
/home/home/p/g/n/pristine/lib/pristine/codegen/elixir.ex
/home/home/p/g/n/pristine/lib/pristine/core/pipeline.ex
/home/home/p/g/n/pristine/lib/pristine/core/context.ex
/home/home/p/g/n/pristine/lib/pristine/streaming/sse_decoder.ex
/home/home/p/g/n/pristine/lib/pristine/ports/future.ex
```

### Sinter Source Files

```
/home/home/p/g/n/sinter/lib/sinter/schema.ex
/home/home/p/g/n/sinter/lib/sinter/types.ex
/home/home/p/g/n/sinter/lib/sinter/validator.ex
```

### Tinker Python SDK (Reference for Manifest Creation)

```
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/resources/models.py
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/resources/sampling.py
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/types/sample_request.py
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/types/sample_result.py
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/types/model.py
/home/home/p/g/North-Shore-AI/tinkex/tinker/src/tinker/_streaming.py
```

### Existing Tinkex Implementation (Reference)

```
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex.ex
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex/client.ex
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex/models.ex
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex/sampling.ex
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex/types/sample_request.ex
/home/home/p/g/North-Shore-AI/tinkex/lib/tinkex/types/sample_result.ex
```

---

## Overview

This stage validates the entire Pristine system by:
1. Creating a complete manifest for the Tinker API (Tinkex)
2. Generating a full Tinkex client from that manifest
3. Running integration tests against mock and real endpoints
4. Verifying feature parity with the hand-written Tinkex

---

## Task 6.1: Tinkex Manifest Creation

### Context

Create a comprehensive Pristine manifest that describes the Tinker API, including:
- All resource endpoints (models, sampling)
- All request/response types
- Streaming endpoints
- Async/future endpoints
- Authentication configuration

### Files to Create

- `/home/home/p/g/n/pristine/examples/tinkex/manifest.json`
- `/home/home/p/g/n/pristine/examples/tinkex/README.md`

### Manifest Structure

Create `/home/home/p/g/n/pristine/examples/tinkex/manifest.json`:

```json
{
  "$schema": "https://pristine.dev/manifest.schema.json",
  "name": "Tinkex",
  "version": "1.0.0",
  "description": "Elixir client for the Tinker AI API, generated by Pristine",
  "base_url": "https://api.tinker.ai/v1",

  "auth": {
    "type": "bearer",
    "header": "Authorization",
    "env_var": "TINKER_API_KEY"
  },

  "config": {
    "module_prefix": "Tinkex",
    "generate_types": true,
    "generate_docs": true,
    "group_by_resource": true
  },

  "resources": [
    {
      "id": "models",
      "name": "Models",
      "description": "Manage and interact with AI models"
    },
    {
      "id": "sampling",
      "name": "Sampling",
      "description": "Generate text samples from models"
    }
  ],

  "endpoints": [
    {
      "id": "list_models",
      "resource": "models",
      "method": "get",
      "path": "/models",
      "description": "List all available models",
      "response_type": "model_list"
    },
    {
      "id": "get_model",
      "resource": "models",
      "method": "get",
      "path": "/models/{model_id}",
      "description": "Get details for a specific model",
      "response_type": "model"
    },
    {
      "id": "create_sample",
      "resource": "sampling",
      "method": "post",
      "path": "/samples",
      "description": "Create a new sample from a model",
      "request_type": "sample_request",
      "response_type": "sample_result",
      "idempotent": true,
      "idempotency_header": "X-Idempotency-Key"
    },
    {
      "id": "create_sample_stream",
      "resource": "sampling",
      "method": "post",
      "path": "/samples",
      "description": "Create a streaming sample from a model",
      "request_type": "sample_request",
      "response_type": "sample_stream_event",
      "streaming": true,
      "stream_format": "sse"
    },
    {
      "id": "get_sample",
      "resource": "sampling",
      "method": "get",
      "path": "/samples/{sample_id}",
      "description": "Get a sample result by ID",
      "response_type": "sample_result"
    },
    {
      "id": "create_sample_async",
      "resource": "sampling",
      "method": "post",
      "path": "/samples/async",
      "description": "Create a sample asynchronously, returns a future",
      "request_type": "sample_request",
      "response_type": "async_sample_response",
      "async": true,
      "poll_endpoint": "get_sample"
    }
  ],

  "types": [
    {
      "id": "model",
      "description": "An AI model available for sampling",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "id", "type": "string", "required": true, "description": "Unique model identifier"},
          {"name": "name", "type": "string", "required": true, "description": "Human-readable model name"},
          {"name": "description", "type": "string", "description": "Model description"},
          {"name": "context_length", "type": "integer", "required": true, "description": "Maximum context length in tokens"},
          {"name": "capabilities", "type": {"array": "string"}, "description": "List of model capabilities"},
          {"name": "created_at", "type": "string", "format": "datetime", "description": "When the model was created"}
        ]
      }
    },
    {
      "id": "model_list",
      "description": "A paginated list of models",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "data", "type": {"array": "model"}, "required": true},
          {"name": "has_more", "type": "boolean", "required": true},
          {"name": "next_cursor", "type": "string"}
        ]
      }
    },
    {
      "id": "sample_request",
      "description": "Request parameters for creating a sample",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "model", "type": "string", "required": true, "description": "Model ID to use"},
          {"name": "prompt", "type": "string", "required": true, "description": "Input prompt"},
          {"name": "max_tokens", "type": "integer", "default": 1024, "description": "Maximum tokens to generate"},
          {"name": "temperature", "type": "number", "minimum": 0, "maximum": 2, "default": 1.0, "description": "Sampling temperature"},
          {"name": "top_p", "type": "number", "minimum": 0, "maximum": 1, "description": "Nucleus sampling parameter"},
          {"name": "stop_sequences", "type": {"array": "string"}, "description": "Sequences that stop generation"},
          {"name": "stream", "type": "boolean", "default": false, "description": "Whether to stream the response"},
          {"name": "metadata", "type": {"map": "string"}, "description": "Custom metadata to attach"}
        ]
      }
    },
    {
      "id": "sample_result",
      "description": "The result of a sampling request",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "id", "type": "string", "required": true, "description": "Unique sample ID"},
          {"name": "model", "type": "string", "required": true, "description": "Model used"},
          {"name": "content", "type": {"array": "content_block"}, "required": true, "description": "Generated content blocks"},
          {"name": "stop_reason", "type": "stop_reason", "required": true, "description": "Why generation stopped"},
          {"name": "usage", "type": "usage", "required": true, "description": "Token usage information"},
          {"name": "created_at", "type": "string", "format": "datetime", "required": true}
        ]
      }
    },
    {
      "id": "content_block",
      "description": "A block of generated content",
      "schema": {
        "type": "discriminated_union",
        "discriminator": "type",
        "variants": {
          "text": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "text"}, "required": true},
              {"name": "text", "type": "string", "required": true}
            ]
          },
          "tool_use": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "tool_use"}, "required": true},
              {"name": "id", "type": "string", "required": true},
              {"name": "name", "type": "string", "required": true},
              {"name": "input", "type": {"map": "any"}, "required": true}
            ]
          }
        }
      }
    },
    {
      "id": "stop_reason",
      "description": "Reason why generation stopped",
      "schema": {
        "type": "union",
        "variants": [
          {"literal": "end_turn"},
          {"literal": "max_tokens"},
          {"literal": "stop_sequence"},
          {"literal": "tool_use"}
        ]
      }
    },
    {
      "id": "usage",
      "description": "Token usage information",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "input_tokens", "type": "integer", "required": true},
          {"name": "output_tokens", "type": "integer", "required": true}
        ]
      }
    },
    {
      "id": "sample_stream_event",
      "description": "A streaming event during sample generation",
      "schema": {
        "type": "discriminated_union",
        "discriminator": "type",
        "variants": {
          "message_start": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "message_start"}, "required": true},
              {"name": "message", "type": "partial_sample_result", "required": true}
            ]
          },
          "content_block_start": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "content_block_start"}, "required": true},
              {"name": "index", "type": "integer", "required": true},
              {"name": "content_block", "type": "content_block", "required": true}
            ]
          },
          "content_block_delta": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "content_block_delta"}, "required": true},
              {"name": "index", "type": "integer", "required": true},
              {"name": "delta", "type": "content_delta", "required": true}
            ]
          },
          "content_block_stop": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "content_block_stop"}, "required": true},
              {"name": "index", "type": "integer", "required": true}
            ]
          },
          "message_delta": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "message_delta"}, "required": true},
              {"name": "delta", "type": "message_delta_data", "required": true},
              {"name": "usage", "type": "usage", "required": true}
            ]
          },
          "message_stop": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "message_stop"}, "required": true}
            ]
          },
          "ping": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "ping"}, "required": true}
            ]
          },
          "error": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "error"}, "required": true},
              {"name": "error", "type": "api_error", "required": true}
            ]
          }
        }
      }
    },
    {
      "id": "content_delta",
      "description": "Delta update for content block",
      "schema": {
        "type": "discriminated_union",
        "discriminator": "type",
        "variants": {
          "text_delta": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "text_delta"}, "required": true},
              {"name": "text", "type": "string", "required": true}
            ]
          },
          "input_json_delta": {
            "type": "map",
            "properties": [
              {"name": "type", "type": {"literal": "input_json_delta"}, "required": true},
              {"name": "partial_json", "type": "string", "required": true}
            ]
          }
        }
      }
    },
    {
      "id": "message_delta_data",
      "description": "Delta update for message",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "stop_reason", "type": "stop_reason"},
          {"name": "stop_sequence", "type": "string"}
        ]
      }
    },
    {
      "id": "partial_sample_result",
      "description": "Partial sample result at stream start",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "id", "type": "string", "required": true},
          {"name": "model", "type": "string", "required": true},
          {"name": "usage", "type": "usage", "required": true}
        ]
      }
    },
    {
      "id": "async_sample_response",
      "description": "Response when creating an async sample",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "id", "type": "string", "required": true, "description": "Sample ID to poll"},
          {"name": "status", "type": "async_status", "required": true},
          {"name": "poll_url", "type": "string", "required": true}
        ]
      }
    },
    {
      "id": "async_status",
      "description": "Status of an async operation",
      "schema": {
        "type": "union",
        "variants": [
          {"literal": "pending"},
          {"literal": "processing"},
          {"literal": "completed"},
          {"literal": "failed"}
        ]
      }
    },
    {
      "id": "api_error",
      "description": "API error details",
      "schema": {
        "type": "map",
        "properties": [
          {"name": "type", "type": "string", "required": true},
          {"name": "message", "type": "string", "required": true}
        ]
      }
    }
  ],

  "error_types": [
    {
      "status": 400,
      "type": "invalid_request_error",
      "description": "The request was malformed"
    },
    {
      "status": 401,
      "type": "authentication_error",
      "description": "Invalid or missing API key"
    },
    {
      "status": 403,
      "type": "permission_error",
      "description": "Not authorized for this resource"
    },
    {
      "status": 404,
      "type": "not_found_error",
      "description": "The requested resource was not found"
    },
    {
      "status": 429,
      "type": "rate_limit_error",
      "description": "Too many requests"
    },
    {
      "status": 500,
      "type": "api_error",
      "description": "Internal server error"
    },
    {
      "status": 529,
      "type": "overloaded_error",
      "description": "API is temporarily overloaded"
    }
  ]
}
```

### Manifest Tests

Create `/home/home/p/g/n/pristine/test/examples/tinkex_manifest_test.exs`:

```elixir
defmodule Examples.TinkexManifestTest do
  use ExUnit.Case, async: true

  alias Pristine.Manifest

  @manifest_path "examples/tinkex/manifest.json"

  describe "tinkex manifest" do
    test "loads successfully" do
      assert {:ok, manifest} = Manifest.load_file(@manifest_path)
      assert manifest.name == "Tinkex"
    end

    test "has all required endpoints" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      endpoint_ids = Enum.map(manifest.endpoints, & &1.id)

      assert :list_models in endpoint_ids
      assert :get_model in endpoint_ids
      assert :create_sample in endpoint_ids
      assert :create_sample_stream in endpoint_ids
      assert :get_sample in endpoint_ids
      assert :create_sample_async in endpoint_ids
    end

    test "has all required types" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      type_ids = Enum.map(manifest.types, & &1.id)

      assert :model in type_ids
      assert :model_list in type_ids
      assert :sample_request in type_ids
      assert :sample_result in type_ids
      assert :content_block in type_ids
      assert :sample_stream_event in type_ids
    end

    test "validates against Pristine schema" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      assert :ok = Manifest.validate(manifest)
    end

    test "streaming endpoint has stream configuration" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      stream_endpoint = Enum.find(manifest.endpoints, & &1.id == :create_sample_stream)

      assert stream_endpoint.streaming == true
      assert stream_endpoint.stream_format == :sse
    end

    test "async endpoint has poll configuration" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      async_endpoint = Enum.find(manifest.endpoints, & &1.id == :create_sample_async)

      assert async_endpoint.async == true
      assert async_endpoint.poll_endpoint == :get_sample
    end

    test "types with discriminated unions are valid" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      content_block = Enum.find(manifest.types, & &1.id == :content_block)

      assert content_block.schema.type == :discriminated_union
      assert content_block.schema.discriminator == "type"
      assert Map.has_key?(content_block.schema.variants, "text")
      assert Map.has_key?(content_block.schema.variants, "tool_use")
    end
  end
end
```

---

## Task 6.2: Generate Tinkex from Manifest

### Context

Use Pristine codegen to generate a complete Tinkex client from the manifest created in Task 6.1.

### Files to Create

Generated output in `/home/home/p/g/n/pristine/examples/tinkex/generated/`:
- `lib/tinkex.ex` - Main module
- `lib/tinkex/client.ex` - Client struct and configuration
- `lib/tinkex/models.ex` - Models resource module
- `lib/tinkex/sampling.ex` - Sampling resource module
- `lib/tinkex/types/*.ex` - Type modules
- `lib/tinkex/streaming.ex` - Streaming support
- `lib/tinkex/future.ex` - Future/async support

### Implementation

Add generation Mix task if not exists. Create test that generates and verifies:

Create `/home/home/p/g/n/pristine/test/examples/tinkex_generation_test.exs`:

```elixir
defmodule Examples.TinkexGenerationTest do
  use ExUnit.Case

  alias Pristine.Manifest
  alias Pristine.Codegen

  @manifest_path "examples/tinkex/manifest.json"
  @output_path "examples/tinkex/generated"

  setup do
    # Clean output directory
    File.rm_rf!(@output_path)
    File.mkdir_p!(@output_path)
    :ok
  end

  describe "tinkex generation" do
    test "generates all expected files" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)

      assert :ok = Codegen.generate(manifest, output: @output_path)

      # Check main files exist
      assert File.exists?(Path.join(@output_path, "lib/tinkex.ex"))
      assert File.exists?(Path.join(@output_path, "lib/tinkex/client.ex"))
      assert File.exists?(Path.join(@output_path, "lib/tinkex/models.ex"))
      assert File.exists?(Path.join(@output_path, "lib/tinkex/sampling.ex"))

      # Check type files exist
      assert File.exists?(Path.join(@output_path, "lib/tinkex/types/model.ex"))
      assert File.exists?(Path.join(@output_path, "lib/tinkex/types/sample_request.ex"))
      assert File.exists?(Path.join(@output_path, "lib/tinkex/types/sample_result.ex"))
    end

    test "generated code compiles without warnings" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      # Compile the generated code
      files = Path.wildcard(Path.join(@output_path, "lib/**/*.ex"))

      for file <- files do
        assert {:ok, _} = Code.compile_file(file)
      end
    end

    test "generated client module has correct structure" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      content = File.read!(Path.join(@output_path, "lib/tinkex/client.ex"))

      assert content =~ "defmodule Tinkex.Client"
      assert content =~ "defstruct"
      assert content =~ "@type t ::"
      assert content =~ "def new("
    end

    test "generated models module has list and get functions" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      content = File.read!(Path.join(@output_path, "lib/tinkex/models.ex"))

      assert content =~ "defmodule Tinkex.Models"
      assert content =~ "def list("
      assert content =~ "def get("
      assert content =~ "@doc"
      assert content =~ "@spec"
    end

    test "generated sampling module has create and stream functions" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      content = File.read!(Path.join(@output_path, "lib/tinkex/sampling.ex"))

      assert content =~ "defmodule Tinkex.Sampling"
      assert content =~ "def create("
      assert content =~ "def create_stream(" or content =~ "def stream("
      assert content =~ "def create_async(" or content =~ "def async("
    end

    test "generated type modules have schema functions" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      content = File.read!(Path.join(@output_path, "lib/tinkex/types/sample_request.ex"))

      assert content =~ "defmodule Tinkex.Types.SampleRequest"
      assert content =~ "defstruct"
      assert content =~ "@type t ::"
      assert content =~ "def schema"
    end

    test "generates streaming support module" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      # Should generate streaming support
      assert File.exists?(Path.join(@output_path, "lib/tinkex/streaming.ex")) or
             File.read!(Path.join(@output_path, "lib/tinkex/sampling.ex")) =~ "Stream"
    end

    test "generated code passes dialyzer" do
      {:ok, manifest} = Manifest.load_file(@manifest_path)
      :ok = Codegen.generate(manifest, output: @output_path)

      # This would run dialyzer on generated code
      # In practice, this would be a separate CI step
      assert true
    end
  end
end
```

### Mix Task for Generation

Create `/home/home/p/g/n/pristine/lib/mix/tasks/pristine.generate.ex`:

```elixir
defmodule Mix.Tasks.Pristine.Generate do
  @moduledoc """
  Generates an Elixir client from a Pristine manifest.

  ## Usage

      mix pristine.generate --manifest path/to/manifest.json --output lib/

  ## Options

    * `--manifest` - Path to the Pristine manifest file (required)
    * `--output` - Output directory for generated code (default: lib/)
    * `--force` - Overwrite existing files without prompting
  """

  use Mix.Task

  @shortdoc "Generate Elixir client from manifest"

  @impl Mix.Task
  def run(args) do
    {opts, _, _} = OptionParser.parse(args, strict: [
      manifest: :string,
      output: :string,
      force: :boolean
    ])

    manifest_path = opts[:manifest] || raise_missing_manifest()
    output_path = opts[:output] || "lib/"
    force = Keyword.get(opts, :force, false)

    unless force do
      if File.exists?(output_path) && File.ls!(output_path) != [] do
        unless Mix.shell().yes?("Output directory is not empty. Overwrite?") do
          Mix.raise("Aborted")
        end
      end
    end

    manifest = load_manifest!(manifest_path)

    case Pristine.Codegen.generate(manifest, output: output_path) do
      :ok ->
        Mix.shell().info("Generated client in #{output_path}")
      {:error, reason} ->
        Mix.raise("Generation failed: #{inspect(reason)}")
    end
  end

  defp load_manifest!(path) do
    case Pristine.Manifest.load_file(path) do
      {:ok, manifest} -> manifest
      {:error, reason} -> Mix.raise("Failed to load manifest: #{inspect(reason)}")
    end
  end

  defp raise_missing_manifest do
    Mix.raise("--manifest option is required")
  end
end
```

---

## Task 6.3: Integration Tests

### Context

Test the generated client against mock servers and optionally against the real Tinker API.

### Files to Create

- `/home/home/p/g/n/pristine/test/integration/tinkex_mock_test.exs`
- `/home/home/p/g/n/pristine/test/integration/tinkex_live_test.exs` (optional, skipped by default)

### Mock Server Integration Tests

Create `/home/home/p/g/n/pristine/test/integration/tinkex_mock_test.exs`:

```elixir
defmodule Integration.TinkexMockTest do
  use ExUnit.Case, async: false

  alias Pristine.Manifest
  alias Pristine.Test.MockServer

  @manifest_path "examples/tinkex/manifest.json"

  setup do
    {:ok, manifest} = Manifest.load_file(@manifest_path)
    {:ok, server} = MockServer.start(manifest, port: 0)

    on_exit(fn -> MockServer.stop(server) end)

    {:ok, manifest: manifest, server: server, base_url: "http://localhost:#{server.port}"}
  end

  describe "models resource" do
    test "list_models returns model list", %{server: server, base_url: base_url} do
      MockServer.expect(server, :list_models, %{
        status: 200,
        body: %{
          data: [
            %{id: "model-1", name: "Test Model 1", context_length: 4096},
            %{id: "model-2", name: "Test Model 2", context_length: 8192}
          ],
          has_more: false
        }
      })

      # Create client pointing to mock server
      client = create_client(base_url)

      # Call the generated function
      {:ok, result} = Tinkex.Models.list(client)

      assert length(result.data) == 2
      assert Enum.at(result.data, 0).id == "model-1"

      MockServer.verify!(server)
    end

    test "get_model returns single model", %{server: server, base_url: base_url} do
      MockServer.expect(server, :get_model, %{
        status: 200,
        body: %{
          id: "model-1",
          name: "Test Model",
          description: "A test model",
          context_length: 4096,
          capabilities: ["text", "code"]
        }
      })

      client = create_client(base_url)

      {:ok, model} = Tinkex.Models.get(client, "model-1")

      assert model.id == "model-1"
      assert model.name == "Test Model"
      assert "text" in model.capabilities

      MockServer.verify!(server)
    end

    test "get_model returns 404 for unknown model", %{server: server, base_url: base_url} do
      MockServer.expect(server, :get_model, %{
        status: 404,
        body: %{
          type: "not_found_error",
          message: "Model not found"
        }
      })

      client = create_client(base_url)

      assert {:error, %{status: 404}} = Tinkex.Models.get(client, "unknown")
    end
  end

  describe "sampling resource" do
    test "create_sample returns sample result", %{server: server, base_url: base_url} do
      MockServer.expect(server, :create_sample, %{
        status: 200,
        body: %{
          id: "sample-123",
          model: "model-1",
          content: [%{type: "text", text: "Hello, world!"}],
          stop_reason: "end_turn",
          usage: %{input_tokens: 10, output_tokens: 5},
          created_at: "2025-01-01T00:00:00Z"
        }
      })

      client = create_client(base_url)

      request = %Tinkex.Types.SampleRequest{
        model: "model-1",
        prompt: "Hello",
        max_tokens: 100
      }

      {:ok, result} = Tinkex.Sampling.create(client, request)

      assert result.id == "sample-123"
      assert length(result.content) == 1
      assert result.stop_reason == "end_turn"

      MockServer.verify!(server)
    end

    test "create_sample validates request", %{base_url: base_url} do
      client = create_client(base_url)

      # Missing required field
      request = %Tinkex.Types.SampleRequest{
        model: "model-1"
        # prompt is missing
      }

      assert {:error, %{type: :validation_error}} = Tinkex.Sampling.create(client, request)
    end

    test "create_sample with idempotency key", %{server: server, base_url: base_url} do
      MockServer.expect(server, :create_sample, %{status: 200, body: %{id: "sample-1"}})
      MockServer.expect(server, :create_sample, %{status: 200, body: %{id: "sample-1"}})

      client = create_client(base_url)
      request = %Tinkex.Types.SampleRequest{model: "m1", prompt: "test"}

      # Both calls with same key should succeed (second returns cached)
      opts = [idempotency_key: "unique-key-123"]
      {:ok, r1} = Tinkex.Sampling.create(client, request, opts)
      {:ok, r2} = Tinkex.Sampling.create(client, request, opts)

      assert r1.id == r2.id
    end
  end

  describe "streaming" do
    test "create_sample_stream returns enumerable", %{server: server, base_url: base_url} do
      # Set up SSE response
      MockServer.expect(server, :create_sample_stream, %{
        status: 200,
        headers: [{"content-type", "text/event-stream"}],
        body: """
        event: message_start
        data: {"type":"message_start","message":{"id":"msg-1","model":"m1","usage":{"input_tokens":10,"output_tokens":0}}}

        event: content_block_start
        data: {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}

        event: content_block_delta
        data: {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"Hello"}}

        event: content_block_delta
        data: {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":" world"}}

        event: content_block_stop
        data: {"type":"content_block_stop","index":0}

        event: message_stop
        data: {"type":"message_stop"}

        """
      })

      client = create_client(base_url)
      request = %Tinkex.Types.SampleRequest{model: "m1", prompt: "test", stream: true}

      {:ok, stream} = Tinkex.Sampling.create_stream(client, request)

      events = Enum.to_list(stream)

      assert length(events) >= 5
      assert Enum.any?(events, & &1.type == "message_start")
      assert Enum.any?(events, & &1.type == "content_block_delta")
      assert Enum.any?(events, & &1.type == "message_stop")

      # Collect text
      text = events
        |> Enum.filter(& &1.type == "content_block_delta")
        |> Enum.map(& &1.delta.text)
        |> Enum.join()

      assert text == "Hello world"
    end
  end

  describe "async/future operations" do
    test "create_sample_async returns future", %{server: server, base_url: base_url} do
      # First call starts async operation
      MockServer.expect(server, :create_sample_async, %{
        status: 202,
        body: %{
          id: "sample-async-1",
          status: "pending",
          poll_url: "/samples/sample-async-1"
        }
      })

      # Poll returns processing
      MockServer.expect(server, :get_sample, %{
        status: 200,
        body: %{
          id: "sample-async-1",
          status: "processing"
        }
      })

      # Poll returns completed
      MockServer.expect(server, :get_sample, %{
        status: 200,
        body: %{
          id: "sample-async-1",
          model: "m1",
          content: [%{type: "text", text: "Async result"}],
          stop_reason: "end_turn",
          usage: %{input_tokens: 10, output_tokens: 20},
          created_at: "2025-01-01T00:00:00Z"
        }
      })

      client = create_client(base_url)
      request = %Tinkex.Types.SampleRequest{model: "m1", prompt: "test"}

      {:ok, future} = Tinkex.Sampling.create_async(client, request)

      assert future.id == "sample-async-1"
      assert future.status == "pending"

      # Poll until complete
      {:ok, result} = Tinkex.Future.await(future, timeout: 5000)

      assert result.id == "sample-async-1"
      assert Enum.at(result.content, 0).text == "Async result"
    end
  end

  describe "error handling" do
    test "handles rate limit errors with retry-after", %{server: server, base_url: base_url} do
      MockServer.expect(server, :create_sample, %{
        status: 429,
        headers: [{"retry-after", "30"}],
        body: %{
          type: "rate_limit_error",
          message: "Rate limit exceeded"
        }
      })

      client = create_client(base_url)
      request = %Tinkex.Types.SampleRequest{model: "m1", prompt: "test"}

      {:error, error} = Tinkex.Sampling.create(client, request)

      assert error.status == 429
      assert error.retry_after == 30
    end

    test "handles authentication errors", %{server: server, base_url: base_url} do
      MockServer.expect(server, :list_models, %{
        status: 401,
        body: %{
          type: "authentication_error",
          message: "Invalid API key"
        }
      })

      client = create_client(base_url, api_key: "invalid")

      {:error, error} = Tinkex.Models.list(client)

      assert error.status == 401
      assert error.type == "authentication_error"
    end

    test "handles server errors", %{server: server, base_url: base_url} do
      MockServer.expect(server, :list_models, %{
        status: 500,
        body: %{
          type: "api_error",
          message: "Internal server error"
        }
      })

      client = create_client(base_url)

      {:error, error} = Tinkex.Models.list(client)

      assert error.status == 500
    end
  end

  # Helper functions

  defp create_client(base_url, opts \\ []) do
    api_key = Keyword.get(opts, :api_key, "test-api-key")

    Tinkex.Client.new(
      api_key: api_key,
      base_url: base_url
    )
  end
end
```

### Optional Live API Tests

Create `/home/home/p/g/n/pristine/test/integration/tinkex_live_test.exs`:

```elixir
defmodule Integration.TinkexLiveTest do
  use ExUnit.Case, async: false

  # Only run if TINKER_API_KEY is set
  @moduletag :live_api
  @moduletag timeout: 60_000

  setup do
    api_key = System.get_env("TINKER_API_KEY")

    if is_nil(api_key) do
      :skip
    else
      client = Tinkex.Client.new(api_key: api_key)
      {:ok, client: client}
    end
  end

  describe "live API - models" do
    @tag :live_api
    test "list_models returns real models", %{client: client} do
      {:ok, result} = Tinkex.Models.list(client)

      assert is_list(result.data)
      assert length(result.data) > 0

      model = Enum.at(result.data, 0)
      assert is_binary(model.id)
      assert is_integer(model.context_length)
    end
  end

  describe "live API - sampling" do
    @tag :live_api
    test "create_sample generates text", %{client: client} do
      request = %Tinkex.Types.SampleRequest{
        model: "default-model",
        prompt: "Say hello in exactly 3 words.",
        max_tokens: 20
      }

      {:ok, result} = Tinkex.Sampling.create(client, request)

      assert is_binary(result.id)
      assert length(result.content) > 0

      text_block = Enum.find(result.content, & &1.type == "text")
      assert is_binary(text_block.text)
      assert String.length(text_block.text) > 0
    end

    @tag :live_api
    test "create_sample_stream yields events", %{client: client} do
      request = %Tinkex.Types.SampleRequest{
        model: "default-model",
        prompt: "Count from 1 to 5.",
        max_tokens: 50,
        stream: true
      }

      {:ok, stream} = Tinkex.Sampling.create_stream(client, request)

      events = Enum.to_list(stream)

      assert length(events) > 0
      assert Enum.any?(events, & &1.type == "message_start")
      assert Enum.any?(events, & &1.type == "message_stop")
    end
  end
end
```

---

## Task 6.4: Documentation

### Context

Update Pristine documentation to include:
- Getting started guide for manifest-driven development
- Tinkex example walkthrough
- API reference updates

### Files to Create/Update

- `/home/home/p/g/n/pristine/examples/tinkex/README.md`
- `/home/home/p/g/n/pristine/README.md` (update)

### Example README

Create `/home/home/p/g/n/pristine/examples/tinkex/README.md`:

```markdown
# Tinkex Example

This directory contains a complete example of generating an API client using Pristine.

## Overview

Tinkex is an Elixir client for the Tinker AI API, generated entirely from the
`manifest.json` file in this directory.

## Files

- `manifest.json` - The Pristine manifest describing the Tinker API
- `generated/` - Generated Elixir code (output of `mix pristine.generate`)

## Generating the Client

```bash
# From the pristine directory
mix pristine.generate \
  --manifest examples/tinkex/manifest.json \
  --output examples/tinkex/generated
```

## Manifest Structure

The manifest defines:

### Resources

- `models` - List and retrieve AI models
- `sampling` - Create text samples from models

### Endpoints

| ID | Method | Path | Description |
|----|--------|------|-------------|
| `list_models` | GET | `/models` | List available models |
| `get_model` | GET | `/models/{id}` | Get model details |
| `create_sample` | POST | `/samples` | Create a sample |
| `create_sample_stream` | POST | `/samples` | Create streaming sample |
| `create_sample_async` | POST | `/samples/async` | Create async sample |

### Types

The manifest defines 15 types including:
- `model` - AI model metadata
- `sample_request` - Request parameters
- `sample_result` - Sample response
- `content_block` - Discriminated union of content types
- `sample_stream_event` - Streaming event types

## Using the Generated Client

```elixir
# Create a client
client = Tinkex.Client.new(api_key: System.get_env("TINKER_API_KEY"))

# List models
{:ok, models} = Tinkex.Models.list(client)

# Create a sample
request = %Tinkex.Types.SampleRequest{
  model: "default-model",
  prompt: "Hello, world!",
  max_tokens: 100
}
{:ok, result} = Tinkex.Sampling.create(client, request)

# Stream a sample
{:ok, stream} = Tinkex.Sampling.create_stream(client, request)
Enum.each(stream, fn event ->
  case event.type do
    "content_block_delta" -> IO.write(event.delta.text)
    _ -> :ok
  end
end)

# Async sample with future
{:ok, future} = Tinkex.Sampling.create_async(client, request)
{:ok, result} = Tinkex.Future.await(future, timeout: 30_000)
```

## Features Demonstrated

1. **Resource Grouping** - Endpoints grouped into `Models` and `Sampling` modules
2. **Type Generation** - Full type structs with validation
3. **Streaming** - SSE streaming with event parsing
4. **Async/Future** - Polling-based async operations
5. **Error Handling** - Typed errors with retry-after support
6. **Authentication** - Bearer token auth
7. **Idempotency** - Request idempotency keys

## Customizing

To modify the generated client:

1. Edit `manifest.json` to add/modify endpoints or types
2. Re-run `mix pristine.generate`
3. Generated code in `generated/` will be updated

For custom behavior, you can extend the generated modules or implement
custom adapters using Pristine's port system.
```

---

## Verification Checklist

After completing all tasks, verify:

### Manifest Validation
```bash
cd /home/home/p/g/n/pristine
mix pristine.validate --manifest examples/tinkex/manifest.json
```

### Code Generation
```bash
mix pristine.generate \
  --manifest examples/tinkex/manifest.json \
  --output examples/tinkex/generated \
  --force
```

### Generated Code Compilation
```bash
cd examples/tinkex/generated
mix compile --warnings-as-errors
```

### All Tests Pass
```bash
cd /home/home/p/g/n/pristine
mix test test/examples/
mix test test/integration/tinkex_mock_test.exs
```

### Dialyzer on Generated Code
```bash
cd examples/tinkex/generated
mix dialyzer
```

### Credo on Generated Code
```bash
cd examples/tinkex/generated
mix credo --strict
```

### OpenAPI Generation
```bash
mix pristine.openapi --manifest examples/tinkex/manifest.json --output examples/tinkex/openapi.json
```

### Documentation Generation
```bash
mix pristine.docs --manifest examples/tinkex/manifest.json --output examples/tinkex/API.md
```

---

## Success Criteria

1. **Manifest loads and validates** - `mix pristine.validate` passes
2. **Generation succeeds** - All expected files created
3. **Code compiles** - No warnings, no errors
4. **Dialyzer passes** - No type errors in generated code
5. **Credo passes** - Generated code follows style guidelines
6. **Mock tests pass** - All integration tests with mock server pass
7. **Streaming works** - SSE events properly parsed and enumerable
8. **Futures work** - Async polling completes correctly
9. **Error handling works** - API errors properly typed and handled
10. **Documentation complete** - README, API docs, OpenAPI spec all generated

---

## Final Notes

This stage proves that Pristine has achieved its primary goal: **generating production-quality API clients from declarative manifests**.

The Tinkex example demonstrates:
- Full Tinker API parity through manifest definition
- Type-safe request/response handling
- Streaming support via SSE
- Async operations via polling futures
- Comprehensive error handling
- Developer-friendly documentation

Upon completion of this stage, Pristine will be ready for production use in generating API clients for any HTTP-based API that can be described by a manifest.
