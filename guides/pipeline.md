# Pipeline and Request Execution

The Pipeline is the heart of Pristine's runtime, orchestrating request construction, resilience patterns, and response processing. This guide covers how requests flow through the system.

## Pipeline Overview

```
Pipeline.execute()
    │
    ├─► Endpoint Lookup
    │   └─► Fetch from manifest
    │
    ├─► Request Encoding
    │   ├─► Serialize payload
    │   ├─► Apply transformations
    │   └─► Build body
    │
    ├─► Request Building
    │   ├─► URL construction
    │   ├─► Header merging
    │   └─► Auth application
    │
    ├─► Resilience Stack
    │   ├─► Rate limiter
    │   ├─► Circuit breaker
    │   └─► Retry logic
    │
    ├─► Transport
    │   └─► HTTP request/response
    │
    └─► Response Processing
        ├─► Decompress
        ├─► Decode
        ├─► Validate
        └─► Return result
```

## Execution Functions

### Standard Execution

```elixir
{:ok, result} = Pristine.Core.Pipeline.execute(
  manifest,
  endpoint_id,
  payload,
  context,
  opts
)
```

**Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `manifest` | `Manifest.t()` | Loaded manifest |
| `endpoint_id` | `String.t()` or `atom()` | Endpoint identifier |
| `payload` | `map()` | Request payload |
| `context` | `Context.t()` | Runtime context |
| `opts` | `keyword()` | Optional overrides |

**Options:**

| Option | Description |
|--------|-------------|
| `:path_params` | Map of path parameter values |
| `:query_params` | Additional query parameters |
| `:headers` | Additional headers |
| `:timeout` | Override timeout |
| `:idempotency_key` | Custom idempotency key |

### Streaming Execution

```elixir
{:ok, stream_response} = Pristine.Core.Pipeline.execute_stream(
  manifest,
  endpoint_id,
  payload,
  context,
  opts
)
```

Returns `StreamResponse` with lazy event stream. See [Streaming Guide](streaming.md).

### Future Execution

```elixir
{:ok, task} = Pristine.Core.Pipeline.execute_future(
  manifest,
  endpoint_id,
  payload,
  context,
  opts
)

{:ok, result} = Task.await(task, timeout)
```

**Future Options:**

| Option | Description |
|--------|-------------|
| `:poll_interval_ms` | Base polling interval (default: 1000) |
| `:max_poll_time_ms` | Max polling time (default: 300000) |
| `:backoff` | `:none`, `:linear`, or `:exponential` |
| `:on_state_change` | Callback on state changes |

## Request Building

### URL Construction

```elixir
# Manifest endpoint
%{
  "path" => "/users/{user_id}/posts/{post_id}"
}

# Execution
Pipeline.execute(manifest, :get_post, %{}, context,
  path_params: %{"user_id" => "123", "post_id" => "456"}
)

# Result: https://api.example.com/users/123/posts/456
```

**URL Features:**

- Path parameter substitution (`{param}` or `:param`)
- Query string encoding
- Base URL normalization

### Header Building

Headers are merged in priority order:

1. **Base headers** (from context)
2. **Endpoint headers** (from manifest)
3. **Auth headers** (from auth modules)
4. **Extra headers** (from opts)
5. **Content-Type** (from body type)

```elixir
# Context base headers
context = %Context{
  headers: %{"User-Agent" => "MySDK/1.0"}
}

# Endpoint headers (manifest)
%{
  "headers" => %{"Accept" => "application/json"}
}

# Auth headers (generated by auth module)
%{"Authorization" => "Bearer token"}

# Extra headers (opts)
opts = [headers: %{"X-Request-ID" => "abc123"}]

# Final merged headers
%{
  "User-Agent" => "MySDK/1.0",
  "Accept" => "application/json",
  "Authorization" => "Bearer token",
  "X-Request-ID" => "abc123",
  "Content-Type" => "application/json"
}
```

### Authentication

Auth modules are applied in order:

```elixir
context = %Context{
  auth: [
    {Pristine.Adapters.Auth.Bearer, token: "..."},
    {Pristine.Adapters.Auth.APIKey, value: "...", header: "X-API-Key"}
  ]
}
```

Each module's `headers/1` callback is called, and results are merged.

### Body Encoding

**JSON (default):**
```elixir
payload = %{name: "John", age: 30}
# Encoded to: {"name":"John","age":30}
# Content-Type: application/json
```

**Multipart:**
```json
{
  "body_type": "multipart"
}
```

```elixir
payload = %{
  "file" => %{filename: "doc.pdf", content: binary},
  "description" => "My file"
}
# Encoded as multipart/form-data
```

**Raw:**
```json
{
  "body_type": "raw"
}
```

```elixir
payload = "raw binary data"
# Sent as-is
```

## Resilience Stack

### Order of Operations

```
Rate Limiter (outermost)
  └─► Circuit Breaker
       └─► Retry Logic
            └─► Transport (innermost)
```

### Rate Limiting

```elixir
rate_limiter.within_limit(fn ->
  # Rest of pipeline
end, key: rate_limit_key)
```

The rate limiter:
- Blocks if limit exceeded
- Respects server-driven backoff (429 responses)
- Per-endpoint key isolation

### Circuit Breaking

```elixir
circuit_breaker.call(endpoint_key, fn ->
  # Retry and transport
end, [])
```

The circuit breaker:
- Opens after repeated failures
- Prevents cascading failures
- Per-endpoint circuit isolation

### Retry Logic

```elixir
retry.with_retry(fn ->
  transport.send(request, context)
end, policy: retry_policy)
```

**Retry Decisions:**

| Condition | Retry? |
|-----------|--------|
| Status 429 | Yes (with backoff) |
| Status 5xx | Yes |
| Connection error | Yes |
| Status 4xx (not 429) | No |
| Validation error | No |

**Backoff Strategies:**

- **Exponential**: 1s → 2s → 4s → 8s...
- **Linear**: 1s → 2s → 3s → 4s...
- **Constant**: 1s → 1s → 1s...

### Idempotency

For safe retries:

```elixir
# Auto-generated
idempotency_key = UUID.uuid4()

# Or specified
Pipeline.execute(manifest, :create, payload, context,
  idempotency_key: "my-key-123"
)
```

The key is sent via the configured header (default: `Idempotency-Key`).

## Response Processing

### Response Normalization

```elixir
# Transport returns
%Response{
  status: 200,
  headers: %{"content-encoding" => "gzip"},
  body: <<compressed_data>>
}

# Normalized to
%Response{
  status: 200,
  headers: %{...},
  body: "decompressed json string"
}
```

### Decompression

If `content-encoding: gzip`:
```elixir
body = Pristine.Adapters.Compression.Gzip.decompress(body)
```

### Decoding

```elixir
{:ok, decoded} = serializer.decode(body, response_schema, opts)
```

With schema validation if schema is provided.

### Response Unwrapping

If endpoint has `response_unwrap`:

```json
{
  "response_unwrap": "data.result"
}
```

```elixir
# Response: {"data": {"result": {"id": 1}}}
# Unwrapped: {"id": 1}
```

### Error Handling

**HTTP Errors:**
```elixir
case response.status do
  status when status >= 200 and status < 300 ->
    {:ok, decoded_body}

  status ->
    error = build_error(status, body, context.error_module)
    {:error, error}
end
```

**Custom Error Module:**
```elixir
context = %Context{
  error_module: MyApp.APIError
}

defmodule MyApp.APIError do
  defstruct [:status, :code, :message]

  def new(status, body, _headers) do
    %__MODULE__{
      status: status,
      code: body["error"]["code"],
      message: body["error"]["message"]
    }
  end
end
```

## Context Configuration

### Complete Context

```elixir
context = %Pristine.Core.Context{
  # Base configuration
  config: %{},
  base_url: "https://api.example.com",
  headers: %{"User-Agent" => "MySDK/1.0"},
  default_query: %{},
  default_timeout: 30_000,

  # Transport
  transport: Pristine.Adapters.Transport.Finch,
  stream_transport: Pristine.Adapters.Transport.FinchStream,
  transport_opts: [finch: MyApp.Finch],
  pool_manager: Pristine.Adapters.PoolManager,
  pool_base: :default,

  # Serialization
  serializer: Pristine.Adapters.Serializer.JSON,
  multipart: Pristine.Adapters.Multipart.Ex,

  # Authentication
  auth: [{Pristine.Adapters.Auth.Bearer, token: "..."}],
  idempotency_header: "Idempotency-Key",

  # Resilience
  retry: Pristine.Adapters.Retry.Foundation,
  retry_policies: %{"default" => %{max_attempts: 3}},
  rate_limiter: Pristine.Adapters.RateLimit.BackoffWindow,
  circuit_breaker: Pristine.Adapters.CircuitBreaker.Foundation,

  # Observability
  telemetry: Pristine.Adapters.Telemetry.Foundation,
  telemetry_events: %{},
  telemetry_metadata: %{},
  dump_headers?: false,
  redact_headers: &default_redact/1,

  # Type system
  type_schemas: %{},
  transform_opts: %{},
  query_opts: %{},

  # Advanced
  semaphore: nil,
  future: Pristine.Adapters.Future.Polling,
  response_wrapper: nil,
  error_module: nil,
  extra_headers: nil,
  package_version: "1.0.0"
}
```

### Context Factory

```elixir
context = Pristine.context(
  base_url: "https://api.example.com",
  transport: Pristine.Adapters.Transport.Finch,
  # ... other options
)
```

## Telemetry

### Events Emitted

| Event | Measurements | Metadata |
|-------|--------------|----------|
| `[:pristine, :request, :start]` | - | endpoint, method, url |
| `[:pristine, :request, :stop]` | duration | endpoint, status |
| `[:pristine, :request, :exception]` | duration | endpoint, error |

### Attaching Handlers

```elixir
:telemetry.attach_many(
  "my-handler",
  [
    [:pristine, :request, :start],
    [:pristine, :request, :stop],
    [:pristine, :request, :exception]
  ],
  fn event, measurements, metadata, _config ->
    case event do
      [:pristine, :request, :stop] ->
        Logger.info("#{metadata.endpoint_id} completed in #{measurements.duration}ms")

      [:pristine, :request, :exception] ->
        Logger.error("#{metadata.endpoint_id} failed: #{inspect(metadata.error)}")

      _ ->
        :ok
    end
  end,
  nil
)
```

### Custom Event Names

```elixir
context = %Context{
  telemetry_events: %{
    request_start: [:myapp, :api, :request, :start],
    request_stop: [:myapp, :api, :request, :stop]
  }
}
```

## Debugging

### Header Dumping

```elixir
context = %Context{
  dump_headers?: true,
  redact_headers: fn headers ->
    Map.update(headers, "authorization", "[REDACTED]", fn _ -> "[REDACTED]" end)
  end
}
```

Logs request/response headers (with redaction).

### Request Metadata

Every request includes metadata:

```elixir
%Request{
  metadata: %{
    endpoint_id: "create_user",
    pool_base: :default,
    start_time: -576460750000000
  }
}
```

### Response Metadata

```elixir
%Response{
  metadata: %{
    # Transport-provided metadata
  }
}
```

## Error Types

### Pipeline Errors

```elixir
{:error, :endpoint_not_found}
{:error, :missing_serializer}
{:error, :missing_transport}
{:error, {:validation_error, errors}}
{:error, {:transport_error, reason}}
{:error, {:decode_error, reason}}
```

### HTTP Errors

With default error handling:
```elixir
{:error, %Pristine.Error{
  status: 404,
  body: %{"error" => "Not found"},
  headers: %{...}
}}
```

With custom error module:
```elixir
{:error, %MyApp.APIError{
  status: 404,
  code: "not_found",
  message: "Resource not found"
}}
```

## Example: Complete Request Flow

```elixir
# 1. Load manifest
{:ok, manifest} = Pristine.load_manifest_file("manifest.json")

# 2. Build context
context = Pristine.context(
  base_url: "https://api.example.com",
  transport: Pristine.Adapters.Transport.Finch,
  transport_opts: [finch: MyApp.Finch],
  serializer: Pristine.Adapters.Serializer.JSON,
  auth: [{Pristine.Adapters.Auth.Bearer, token: "secret"}],
  retry: Pristine.Adapters.Retry.Foundation,
  retry_policies: %{"default" => %{max_attempts: 3}},
  telemetry: Pristine.Adapters.Telemetry.Foundation
)

# 3. Execute
case Pristine.Core.Pipeline.execute(
  manifest,
  :create_user,
  %{name: "John", email: "john@example.com"},
  context,
  timeout: 10_000
) do
  {:ok, user} ->
    IO.inspect(user, label: "Created user")

  {:error, %{status: 422, body: body}} ->
    IO.puts("Validation failed: #{inspect(body)}")

  {:error, reason} ->
    IO.puts("Error: #{inspect(reason)}")
end
```
