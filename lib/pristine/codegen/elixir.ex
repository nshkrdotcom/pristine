defmodule Pristine.Codegen.Elixir do
  @moduledoc """
  Render Elixir modules from a manifest.
  """

  @spec render_type_module(String.t(), String.t(), map()) :: String.t()
  def render_type_module(namespace, type_name, type_def) do
    module_name = "#{namespace}.#{type_name}"
    fields_source = render_fields(type_def)

    """
    defmodule #{module_name} do
      @moduledoc false

      def schema() do
        Sinter.Schema.define([
    #{fields_source}
        ])
      end
    end
    """
  end

  @spec render_client_module(String.t(), map()) :: String.t()
  def render_client_module(module_name, manifest) when is_map(manifest) do
    manifest_literal = inspect(manifest, pretty: true)
    endpoint_fns = render_endpoints(manifest)
    moduledoc = render_moduledoc(manifest)

    """
    defmodule #{module_name} do
    #{moduledoc}
      @manifest #{manifest_literal}

      def manifest(), do: @manifest

    #{endpoint_fns}

      @doc "Execute an endpoint by ID."
      @spec execute(atom() | String.t(), map(), Pristine.Core.Context.t(), keyword()) ::
              {:ok, term()} | {:error, term()}
      def execute(endpoint_id, payload, context, opts \\\\ []) do
        Pristine.Runtime.execute(@manifest, endpoint_id, payload, context, opts)
      end
    end
    """
  end

  @doc """
  Renders a single endpoint function with documentation.
  """
  @spec render_endpoint_fn(map()) :: String.t()
  def render_endpoint_fn(endpoint) when is_map(endpoint) do
    id = Map.get(endpoint, :id) || Map.get(endpoint, "id")

    if is_nil(id) do
      ""
    else
      fn_name = normalize_key(id)
      doc = render_endpoint_doc(endpoint)
      spec = render_endpoint_spec(fn_name)

      """
      #{doc}#{spec}  def #{fn_name}(payload, context, opts \\\\ []) do
          Pristine.Runtime.execute(@manifest, #{inspect(normalize_key(id))}, payload, context, opts)
        end
      """
    end
  end

  # Private functions

  defp render_moduledoc(manifest) do
    name = Map.get(manifest, :name) || Map.get(manifest, "name") || "API"
    version = Map.get(manifest, :version) || Map.get(manifest, "version") || "unknown"

    """
      @moduledoc \"\"\"
      Generated API client for #{name} v#{version}.

      This module was generated by Pristine from a manifest definition.
      \"\"\"
    """
  end

  defp render_endpoints(%{endpoints: endpoints}) when is_list(endpoints) do
    Enum.map_join(endpoints, "\n\n", &render_endpoint_fn/1)
  end

  defp render_endpoints(_), do: ""

  defp render_endpoint_doc(endpoint) do
    desc = Map.get(endpoint, :description) || Map.get(endpoint, "description")

    if is_nil(desc) or desc == "" do
      ""
    else
      """
        @doc \"\"\"
        #{String.trim(desc)}
        \"\"\"
      """
    end
  end

  defp render_endpoint_spec(fn_name) do
    """
      @spec #{fn_name}(map(), Pristine.Core.Context.t(), keyword()) ::
              {:ok, term()} | {:error, term()}
    """
  end

  defp render_fields(%{fields: fields}) when is_map(fields) do
    Enum.map_join(fields, "\n", fn {name, defn} -> render_field(name, defn) end)
  end

  defp render_fields(_), do: ""

  defp render_field(name, defn) do
    field_name = normalize_key(name)
    type = normalize_type(defn)
    opts = render_field_opts(defn)

    """
          {#{inspect(field_name)}, #{type}, #{opts}}
    """
  end

  defp render_field_opts(defn) do
    opts =
      []
      |> maybe_add_opt(:required, fetch(defn, :required))
      |> maybe_add_opt(:optional, fetch(defn, :optional))
      |> maybe_add_opt(:default, fetch(defn, :default))
      |> maybe_add_opt(:description, fetch(defn, :description))
      |> maybe_add_opt(:min_length, fetch(defn, :min_length))
      |> maybe_add_opt(:max_length, fetch(defn, :max_length))
      |> maybe_add_opt(:min_items, fetch(defn, :min_items))
      |> maybe_add_opt(:max_items, fetch(defn, :max_items))
      |> maybe_add_opt(:gt, fetch(defn, :gt))
      |> maybe_add_opt(:gteq, fetch(defn, :gteq))
      |> maybe_add_opt(:lt, fetch(defn, :lt))
      |> maybe_add_opt(:lteq, fetch(defn, :lteq))
      |> maybe_add_opt(:format, fetch(defn, :format))
      |> maybe_add_opt(:choices, fetch(defn, :choices))

    inspect(opts)
  end

  defp maybe_add_opt(opts, _key, nil), do: opts
  defp maybe_add_opt(opts, _key, false), do: opts
  defp maybe_add_opt(opts, key, true), do: Keyword.put(opts, key, true)
  defp maybe_add_opt(opts, key, value), do: Keyword.put(opts, key, value)

  defp normalize_type(defn) do
    type = fetch(defn, :type) || "string"

    case normalize_key(type) do
      "array" ->
        inner = normalize_type(fetch(defn, :items) || "string")
        "{:array, #{inner}}"

      other ->
        ":#{other}"
    end
  end

  defp normalize_key(key) when is_atom(key), do: Atom.to_string(key)
  defp normalize_key(key) when is_binary(key), do: key
  defp normalize_key(key), do: to_string(key)

  defp fetch(defn, key), do: Map.get(defn, key) || Map.get(defn, to_string(key))
end
