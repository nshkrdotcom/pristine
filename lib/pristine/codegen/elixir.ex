defmodule Pristine.Codegen.Elixir do
  @moduledoc """
  Render Elixir modules from a manifest.
  """

  @spec render_type_module(String.t(), String.t(), map()) :: String.t()
  def render_type_module(namespace, type_name, type_def) do
    module_name = "#{namespace}.#{type_name}"
    fields_source = render_fields(type_def)

    """
    defmodule #{module_name} do
      @moduledoc false

      def schema() do
        Sinter.Schema.define([
    #{fields_source}
        ])
      end
    end
    """
  end

  @spec render_client_module(String.t(), map()) :: String.t()
  def render_client_module(module_name, manifest) when is_map(manifest) do
    manifest_literal = inspect(manifest, pretty: true, limit: :infinity)
    moduledoc = render_moduledoc(manifest)
    endpoints = Map.get(manifest, :endpoints) || Map.get(manifest, "endpoints") || []
    resources = get_unique_resources(endpoints)
    ungrouped = get_ungrouped_endpoints(endpoints)
    base_namespace = get_base_namespace(module_name)

    """
    defmodule #{module_name} do
    #{moduledoc}
      alias Pristine.Core.Context

      defstruct [:context]

      @type t :: %__MODULE__{context: Context.t()}

      @manifest #{manifest_literal}

      @doc "Returns the manifest used to generate this client."
      @spec manifest() :: map()
      def manifest, do: @manifest

      @doc \"\"\"
      Create a new client instance.

      ## Options

        * `:base_url` - Override the default base URL
        * `:headers` - Additional headers to include
        * `:auth` - Authentication configuration
        * `:transport` - Transport adapter module
        * `:timeout` - Request timeout in milliseconds

      \"\"\"
      @spec new(keyword()) :: t()
      def new(opts \\\\ []) do
        %__MODULE__{context: Context.new(opts)}
      end

    #{render_resource_accessors(base_namespace, resources)}
    #{render_ungrouped_endpoints(ungrouped)}

      @doc "Execute an endpoint by ID."
      @spec execute(atom() | String.t(), map(), Pristine.Core.Context.t(), keyword()) ::
              {:ok, term()} | {:error, term()}
      def execute(endpoint_id, payload, context, opts \\\\ []) do
        Pristine.Runtime.execute(@manifest, endpoint_id, payload, context, opts)
      end
    end
    """
  end

  @doc """
  Renders a single endpoint function with documentation.
  """
  @spec render_endpoint_fn(map()) :: String.t()
  def render_endpoint_fn(endpoint) when is_map(endpoint) do
    id = Map.get(endpoint, :id) || Map.get(endpoint, "id")

    if is_nil(id) do
      ""
    else
      fn_name = normalize_key(id)
      doc = render_endpoint_doc(endpoint)
      spec = render_endpoint_spec(fn_name)

      """
      #{doc}#{spec}  def #{fn_name}(payload, context, opts \\\\ []) do
          Pristine.Runtime.execute(@manifest, #{inspect(normalize_key(id))}, payload, context, opts)
        end
      """
    end
  end

  # Private functions

  defp render_moduledoc(manifest) do
    name = Map.get(manifest, :name) || Map.get(manifest, "name") || "API"
    version = Map.get(manifest, :version) || Map.get(manifest, "version") || "unknown"

    """
      @moduledoc \"\"\"
      Generated API client for #{name} v#{version}.

      This module was generated by Pristine from a manifest definition.
      \"\"\"
    """
  end

  defp render_endpoint_doc(endpoint) do
    desc = Map.get(endpoint, :description) || Map.get(endpoint, "description")

    if is_nil(desc) or desc == "" do
      ""
    else
      """
        @doc \"\"\"
        #{String.trim(desc)}
        \"\"\"
      """
    end
  end

  defp render_endpoint_spec(fn_name) do
    """
      @spec #{fn_name}(map(), Pristine.Core.Context.t(), keyword()) ::
              {:ok, term()} | {:error, term()}
    """
  end

  defp render_fields(%{fields: fields}) when is_map(fields) do
    Enum.map_join(fields, "\n", fn {name, defn} -> render_field(name, defn) end)
  end

  defp render_fields(_), do: ""

  defp render_field(name, defn) do
    field_name = normalize_key(name)
    type = normalize_type(defn)
    opts = render_field_opts(defn)

    """
          {#{inspect(field_name)}, #{type}, #{opts}}
    """
  end

  defp render_field_opts(defn) do
    opts =
      []
      |> maybe_add_opt(:required, fetch(defn, :required))
      |> maybe_add_opt(:optional, fetch(defn, :optional))
      |> maybe_add_opt(:default, fetch(defn, :default))
      |> maybe_add_opt(:description, fetch(defn, :description))
      |> maybe_add_opt(:min_length, fetch(defn, :min_length))
      |> maybe_add_opt(:max_length, fetch(defn, :max_length))
      |> maybe_add_opt(:min_items, fetch(defn, :min_items))
      |> maybe_add_opt(:max_items, fetch(defn, :max_items))
      |> maybe_add_opt(:gt, fetch(defn, :gt))
      |> maybe_add_opt(:gteq, fetch(defn, :gteq))
      |> maybe_add_opt(:lt, fetch(defn, :lt))
      |> maybe_add_opt(:lteq, fetch(defn, :lteq))
      |> maybe_add_opt(:format, fetch(defn, :format))
      |> maybe_add_opt(:choices, fetch(defn, :choices))

    inspect(opts)
  end

  defp maybe_add_opt(opts, _key, nil), do: opts
  defp maybe_add_opt(opts, _key, false), do: opts
  defp maybe_add_opt(opts, key, true), do: Keyword.put(opts, key, true)
  defp maybe_add_opt(opts, key, value), do: Keyword.put(opts, key, value)

  defp normalize_type(defn) do
    type = fetch(defn, :type) || "string"

    case normalize_key(type) do
      "array" ->
        inner = normalize_type(fetch(defn, :items) || "string")
        "{:array, #{inner}}"

      other ->
        ":#{other}"
    end
  end

  defp normalize_key(key) when is_atom(key), do: Atom.to_string(key)
  defp normalize_key(key) when is_binary(key), do: key
  defp normalize_key(key), do: to_string(key)

  defp fetch(defn, key), do: Map.get(defn, key) || Map.get(defn, to_string(key))

  # Resource accessor helpers

  defp get_unique_resources(endpoints) when is_list(endpoints) do
    endpoints
    |> Enum.map(fn ep ->
      Map.get(ep, :resource) || Map.get(ep, "resource")
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.uniq()
  end

  defp get_unique_resources(_), do: []

  defp get_ungrouped_endpoints(endpoints) when is_list(endpoints) do
    Enum.filter(endpoints, fn ep ->
      resource = Map.get(ep, :resource) || Map.get(ep, "resource")
      is_nil(resource)
    end)
  end

  defp get_ungrouped_endpoints(_), do: []

  defp get_base_namespace(module_name) do
    # Remove ".Client" suffix if present to get base namespace
    String.replace_suffix(module_name, ".Client", "")
  end

  defp render_resource_accessors(_namespace, []), do: ""

  defp render_resource_accessors(namespace, resources) do
    Enum.map_join(resources, "\n", fn resource ->
      module = resource_to_module_name(namespace, resource)

      """
        @doc "Access #{resource} resource endpoints."
        @spec #{resource}(t()) :: #{module}.t()
        def #{resource}(%__MODULE__{} = client) do
          #{module}.with_client(client)
        end
      """
    end)
  end

  defp render_ungrouped_endpoints([]), do: ""

  defp render_ungrouped_endpoints(endpoints) do
    Enum.map_join(endpoints, "\n\n", &render_endpoint_fn/1)
  end

  defp resource_to_module_name(namespace, resource) do
    module_part = resource |> String.split("_") |> Enum.map_join(&String.capitalize/1)
    "#{namespace}.#{module_part}"
  end
end
